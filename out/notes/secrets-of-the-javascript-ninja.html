<!DOCTYPE html>
<html lang="en" class="no-js">
    <head>
        <meta charset="utf-8" />
        <!--
        ***********************************************************************
        ArnaudBrousseau.com || v5 || Copyright Â© Arnaud Brousseau 2009-2014
        ***********************************************************************
        Are you reading this? You're awesome. You're reading the source.

        Feel free to look around. If you spot something interesting, weird or
        awesome or outright wrong don't hesitate to contact me. I don't bite.
        I'm <first-name>.<last-name>@gmail.com.

        Oh and if you're wondering: this site is static, built with DocPad.
        Check out how: https://github.com/ArnaudBrousseau/arnaudbrousseau.com

        FYI this site was last generated on:
        Fri Mar 14 2014 21:32:24 GMT-0700 (PDT) (how precise! I know.)
        ***********************************************************************
        -->
        <meta name="description" content="" />
        <meta name="author" content="Arnaud Brousseau" />

        <!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><![endif]-->

        <title>Secrets Of The JavaScript Ninja | Arnaud Brousseau</title>
        <link href="http://fonts.googleapis.com/css?family=PT+Serif:400,700" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="/css/style.css?v=3.2.1" />

        <!-- All JavaScript at the bottom, except for Modernizr which enables HTML5 elements & feature detection -->
        <script src="/js/modernizr-1.5.min.js"></script>
    </head>

    <body>
        <header>
            <nav class="nav-container">
                <a href="/" class="nav-link " title="Go back home">Home</a>
                <a href="/labs" class="nav-link " title="Check out what I've been cooking">Labs</a>
                <a href="/notes" class="nav-link active" title="Check out what I've been writting">Notes</a>
            </nav>
        </header>

        <section id="main">
            <h1 class="title note-title">Secrets Of The JavaScript Ninja</h1>
<p class="note-subtitle">
    <em class="note-subtitle-content">Last edited on
        <time datetime="2013-10-17">October 17th 2013</time>
        by
        <a href="https://google.com/+ArnaudBrousseau?rel=author" target="_blank" rel="author">Arnaud Brousseau</a>
    </em>
</p>

<div class="note-content">
    <h2 id="what-is-this-book-who-is-it-for-">What Is This Book? Who Is It For?</h2>
<p><a href="http://www.manning.com/resig/">Secrets Of The JavaScript Ninja</a> is designed
for intermediate to advanced JavaScript programmers. It expects you to have a
firm understanding of JavaScript and a working knowledge of HTML/CSS.<br>The strength of this book lies in its ability to force you to
revisit concepts most JS programmers (including myself) always take for
granted. It puts the focus on functions as objects, function invoking, closures,
cross-browsers strategies, etc.</p>
<p>Resig sets the tone pretty early on. After a short introduction in a chapter
titled &quot;Arming With Testing And Debugging&quot; he tells us about the importance of
testing and goes on to explain how one can create a simple JavaScript
<code>assert</code> method and its associated test runner. Testing is usually briefly
mentioned towards the end of a textbook. Not this time. Testing is mentioned
throughout the book.</p>
<p>So why am I writing about reading &quot;Secrets of the JavaScript Ninja&quot;?
Several reasons:</p>
<ol>
<li>Writing about something helps you remember it better</li>
<li>I&#39;m adding some reference and extra information here and there.</li>
<li>Hopefully this is useful to you, the reader, to a) get a sense of what&#39;s in
this book and b) get better at JavaScript!</li>
</ol>
<p>The remainder of this article is organized in sections, matching roughly the
order of the book&#39;s chapters. In each of those sections I go through what
picked my interest while reading the book, with a focus on concepts that
&quot;clicked&quot; and interesting discoveries.</p>
<h2 id="functions">Functions</h2>
<p>Created via the <code>Function</code> constructor, functions are special objects with
one superpower: they can be <strong>invoked</strong>. Besides that, functions are object and
nothing but objects:</p>
<ul>
<li>they&#39;re created via literals <code>function &lt;optionalName&gt; (&lt;optionalArguments) {&lt;functionBody&gt;}</code></li>
<li>they can be assigned to variables or properties</li>
<li>they can be passed as function parameters and returned as function results</li>
<li>they can have properties and methods. For instance each function has a <code>name</code>
property and a <code>call</code> and <code>apply</code> method. More on that later.</li>
</ul>
<h3 id="function-declaration">Function Declaration</h3>
<p>Two main ways to declare a function:</p>
<pre class="brush: js">
    // option 1
    function blah() { console.log('called'); }
    // option 2
    var blah = function() { console.log('called'); };
</pre>

<p>In both cases the function can be called via <code>blah()</code> after its declaration.
However there&#39;s a crucial difference: in the first case the function is
<strong>named</strong> <code>blah</code> which means the function will be assigned a property <code>name</code>
with the value <code>blah</code>.<br>In the second case, we&#39;re assigning an <strong>anonymous</strong> function to the variable
<code>blah</code>. The function&#39;s <code>name</code> property in this case will be <code>&#39;&#39;</code>.</p>
<h3 id="arguments-and-invocation">Arguments and Invocation</h3>
<p><code>this</code> and <code>arguments</code> are implicit parameters passed to every function. They
are just that. Parameters. The difference between <code>this</code>, <code>arguments</code> and
standard function parameters is that they are <em>implicit</em>. You won&#39;t see them in
 function signatures but they&#39;ll be available from within function bodies.</p>
<h4 id="arguments">Arguments</h4>
<p><code>arguments</code> represent a list of all arguments passed to a function. It has
array-like accessors (<code>arguments[i]</code>) and properties (<code>arguments.length</code>) but
<strong>is not an array</strong> (<code>arguments.slice(1)</code> fails for instance).<br>How can you get around that?</p>
<pre class="brush: js;">
    Object.prototype.toString.call
    Array.prototype.slice.call
    //...etc
</pre>

<h4 id="invoking-a-function-and-this-">Invoking a Function, and <code>this</code></h4>
<p><code>this</code> is defined as the <strong>function context</strong>. Available within a function body,
<code>this</code> should really be referred to as  <strong>invocation context</strong>, because its value
varies based on the way a function is invoked:</p>
<ul>
<li>as a function, <code>this</code> refers to the global context <code>window</code></li>
<li>as a method, <code>this</code> refers to the object owning it</li>
<li>as a constructor, <code>this</code> refers to the newly created object</li>
<li>via <code>call</code> or <code>apply</code>, <code>this</code> is passed in and can be what we want</li>
</ul>
<h3 id="referencing-functions">Referencing Functions</h3>
<p>Referencing functions from within themselves is necessary to achieve recursion.
Resig enumerates four ways.</p>
<p>First option: through a named function. Nothing out of the ordinary.</p>
<pre class="brush: js; highlight: [1,3]">
    function fact(x) {
        if (x !== 1) {
            return x * fact(x - 1);
        } else {
            return 1;
        }
    };
</pre>

<p>Second option: through a method name. Note the danger: if we decide to change
that method&#39;s name to <code>newfact</code>, we&#39;ll have to remember to change the inner
reference to <code>this.newfact</code>.</p>
<pre class="brush: js; highlight: [2,4]">
    var math = {
        'fact': function (x) {
            if (x !== 1) {
                return x * this.fact(x - 1);
            } else {
                return 1;
            }
        }
    };
</pre>

<p>Third option: through inline name. This addresses the shortcoming of the
previous solution.</p>
<pre class="brush: js; highlight: [2,4]">
    var math = {
        'fact': function myfact(x) {
            if (x !== 1) {
                return x * myfact(x - 1);
            } else {
                return 1;
            }
        }
    };
</pre>

<p>Last option: <code>callee</code> (going to go away in later versions of JS, use sparingly).</p>
<pre class="brush: js; highlight: [2,4]">
    var math = {
        'fact': function (x) {
            if (x !== 1) {
                return x * arguments.callee(x - 1);
            } else {
                return 1;
            }
        }
    };
</pre>

<h3 id="auto-memoizing-functions">Auto-Memoizing Functions</h3>
<p>Memoizing by using the object nature of functions:</p>
<pre class="brush: js">
    function getElements(name) {
        if (!getElements.cache) { getElements.cache = {}; }
        return getElements.cache[name] =
            getElements.cache[name] ||
            document.getElementsByTagName(name);
    };
</pre>

<p>You can easily guess how useful these techniques are in a library like
jQuery (actually probably more in Sizzle, jQuery&#39;s DOM access library).</p>
<h3 id="function-overloading">Function Overloading</h3>
<p>Functions have a <code>length</code> property, which corresponds to the number of
arguments declared in their signature. By comparing <code>fn.length</code> and
<code>arguments.length</code>, function overloading can be implemented in a cool way:</p>
<pre class="brush: js">
    function addMethod(object, name, fn) {
        var old = object[name];
        object[name] = function() {
            if (fn.length == arguments.length) {
                return fn.apply(this, arguments);
            } else if (typeof old === 'function') {
            return old.apply(this, arguments);
            }
        };
    };

    // Overloading then becomes a piece of cake. Pretty neat right?
    var obj = {};
    addMethod(obj, 'method', function() { /* do something */ });
    addMethod(obj, 'method', function(a) { /* do something with a */ });
    addMethod(obj, 'method', function(a, b) { /* do something with a and b */ });
</pre>

<h2 id="closures">Closures</h2>
<p>Closures are probably one of the most confusing concepts when someone with a
classical object-oriented background comes to JavaScript.</p>
<p>Resig&#39;s definition of it: <em>&quot;closures allow a function to access all the
variables, as well as other functions, that are in scope when the function
itself is declared.&quot;</em></p>
<p>Later in the chapter: <em>&quot;That&#39;s what closures are all about. They create a
&#39;safety bubble,&#39; if you will, of the function and the variables that are in
scope at the point of the function&#39;s declaration [...] This &#39;bubble,&#39;
containing the function and its variables, stays around as long as the function
itself does.&quot;</em></p>
<p>Let&#39;s look at some code samples to go over the main use cases for closures.</p>
<h3 id="private-variables">Private Variables</h3>
<pre class="brush: js">
    function Counter() {
        var count = 0; // visibility limited to Counter's inner scope
        this.increment = function() { count++; }
        this.getCount = function() { return count; }
    };
    // Can't view/modify count from here. You have to go through Counter.getCount()
</pre>

<h3 id="callbacks-and-timers">Callbacks And Timers</h3>
<p>Callback and timers are in the same vain because the idea here is to use a
closure to host values that the function scheduled to be called back is going
to need when executing. Understanding that a closure&#39;s environment (function,
variables) stays around even when the outer scope has finished its execution is
fundamental.</p>
<pre class="brush: js">
    /**
     * Callback
     */
    var elem = document.getElementById('my-elem');
    $.ajax({
        url: '/my-endpoint',
        success: function() {
            // Here we have access to elem because our outer anonymous
            // function had access to it when it was declared.
            elem.innerHTML('callback executed successfully');
        }
    });

    /**
     * Timer
     */
     function count() {
        var count = 0;
        setInterval(function() {
            // Here we have access to count for the same reason: our outer
            // anonymous function has access to it when it is declared.
            console.log('Count is ' + count);
            count++;
        }, 1000);
     };
</pre>


<h3 id="binding-function-contexts">Binding Function Contexts</h3>
<p>Here closures are used to set the context of functions properly.</p>
<pre class="brush: js">
    // Simple example
    function bind(context, name) {
        return function() {
            // Access to context and name via closure
            return context[name].apply(context, arguments);
        };
    };

    // Example from PrototypeJS
    Function.prototype.bind = function() {
        var fn = this;
        // Turn arguments into a real array
        var args = Array.prototype.slice.call(arguments);
        var ctx = args.shift(); // args is now args[1:n] and object refers
                                // to the first argument
        return function() {
            return fn.apply(
                ctx,
                // `args` refers to the arguments specified at "bind-time"
                // and `arguments` refers to the arguments specified at
                // "call-time".
                // This lets us specify "default" arguments and bind function
                // context at the same time.
                args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    // Sample usage
    var nameSpace = { a: 1, plop: function(b, c) { return this.a + b + c; } }
    var basicBound = basicBind(nameSpace, "plop");
    var bound = nameSpace.plop.bind(nameSpace, 2);
    basicBound(3, 5) // returns 9 (1 + 3 + 5)
    bound(3); // returns 6 (1 + 2 + 3)
</pre>


<h3 id="partial-function-application-currying">Partial Function Application, Currying</h3>
<p>Currying and partials are super simple if you understand <code>bind</code>&#39;s definition
above. It&#39;s essentially the same trick.</p>
<pre class="brush: js">
    Function.prototype.curry = function() {
        var fn = this;
        var args = Array.prototype.slice.call(arguments); // "curry-time" args

        return function() {
            return fn.apply(
                // unmodified context
                this,
                // concatenation of "curry-time" and "call-time" args, in this order
                args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    Function.prototype.partial = function() {
        var fn = this;
        var args = Array.prototype.slice.call(arguments);

        return function() {
            // Here the args manipulation is a bit more tricky since you can
            // leave an undefined param for partial application later on.
            // (see sample usage)
            var arg = 0;
            for (var i=0; i < args.length && arg < arguments.length; i++) {
                if (args[i] === undefined) {
                    args[i] = arguments[arg];
                    arg++;
                }
            }
            return fn.apply(this, args);
        };
    };

    // Sample usage
    var myFunction = function(a, b, c) { return a + b + c; };
    var curried = myFunction.curry(1, 2);
    var partial = myFunction.partial(undefined, 2);
    curried(3); // 6
    partial(1, 4); // 7
</pre>

<h3 id="function-wrapping">Function Wrapping</h3>
<pre class="brush: js">
    function wrap(object, method, wrapper) {
        // Keeps a reference to the original method
        var fn = object[method];

        return object[method] = function() {
            // The wrapper is called with
            // - the original function to be wrapped, as a first argument
            // - the list of arguments to call the original function with
            return wrapper.apply(this, [fn.bind(this)].concat(
                Array.prototype.slice.call(arguments)));
        };
    };

    // Sample usage: automatically adds try/catch on event listeners
    wrap(HTMLElement.prototype, "addEventListener", function(old, type, handler, prop) {
        old(type, function() {
            try {
                handler.apply(this, arguments);
            } catch(e) {
                // Handle error
            }
        }, prop);
    };
</pre>

<h3 id="immediate-functions">Immediate Functions</h3>
<p>Closures are also crucial in IIFEs (<em>Immediately Invoked Function Expression</em>).
Have you always wonder why <code>(function() {})()</code> works the way it does? Well:</p>
<pre class="brush: js">
    // an IIFE like...
    (function() {/* body */})()
    // ...is EXACTLY the same as...
    var myFunc = function() {/* body */};
    (myFunc)();
</pre>

<p>This is clever because it means the body of our IIFE is going to:</p>
<ul>
<li>execute immediately after its declaration</li>
<li>have a reference to the outside scope through the closure it creates</li>
<li>keep all its variables and inner functions isolated and hidden from outside</li>
</ul>
<p>Hence IIFEs are a nice way to create isolated scopes for independent pieces of
functionality. It guarantees no conflict with and no leakage to the outside
world. That&#39;s why most libraries, including jQuery, are wrapped in a IIFE.</p>
<p>Note that you can pass params to an IIFE:<br><code>(function(a, b) {return a + b;})(1, 2)</code></p>
<h2 id="prototypes">Prototypes</h2>
<p>JavaScript Prototypes represent a hard-to-grasp concept because most of us
think about it with the classical object oriented background in the back of our
minds.</p>
<p>In a few sentences Resig made me realize how wrong I&#39;ve been thinking
about prototypes: <em>&quot;prototypes are a convenient way to define types of objets,
but they&#39;re actually a feature of functions&quot;</em>.</p>
<p>And later: &quot;<em>each object in JavaScript has an implicit property named
<code>constructor</code> that references the constructor [function] that was used to
create the object. And because the prototype is a property of the constructor
[function], each object has a way to find its prototype.</em>&quot;<br>Note that I appended <em>[function]</em> to make you realize that constructors are not
a special feature of the language. In fact, <strong>a &quot;constructor&quot; is just a
function invoked in a given way</strong> (using <code>new</code>).</p>
<p>Remember what we discussed before:</p>
<ul>
<li>functions are just objects with the privilege of being <strong>invoked</strong></li>
<li>invoking a function with <code>new</code> will call it with a context set to an empty
object. That object will be returned when the function is done executing.</li>
</ul>
<p>References in objects are resolved on the object itself first. However when a
property fails to be found on the object itself, a property lookup is made <strong>on
the object contructor&#39;s <code>prototype</code> property</strong>. And you guessed already: if an
object constructor&#39;s <code>prototype</code> references an object, lookup can be performed
on that object constructor&#39;s <code>prototype</code>. And so on and so forth. That&#39;s what
<strong>prototype chain lookup</strong> means.</p>
<p>Take the following snippet:</p>
<pre class="brush: js">
    function A() { this.foo = 'bar'; }
    var a = new A();
    A.prototype.baz = 'blah';

    console.log(a.baz); // logs 'blah'
</pre>

<p>What happens in this snippet? A lot!</p>
<ul>
<li>a function <code>A</code> is defined on line 1</li>
<li><code>A</code> is invoked with <code>new</code> on line 2. That means <code>A</code> is called with an
empty object (let&#39;s call it <code>o</code>) as its context</li>
<li><code>o</code> is given a <code>foo</code> property with a value <code>&#39;bar&#39;</code> (we wrote that ourselves)</li>
<li><code>o</code> is given a <code>constructor</code> property. The value is a reference to
function <code>A</code> (that&#39;s automatically handled for us)</li>
<li><code>o</code> is returned (automatically handled for us) and referenced through a variable <code>a</code></li>
<li>on line 3 we define a <code>baz</code> property on <code>A</code>&#39;s <code>prototype</code> property</li>
<li>on line 4 here are the steps to access <code>baz</code> property via <code>a.baz</code>:<ul>
<li><code>a</code> points to an anonymous object <code>o</code>, which does not have a <code>baz</code> property</li>
<li><code>o</code> has a <code>constructor</code> property which points to <code>A</code></li>
<li><code>A</code> has a <code>prototype</code> property which points to an anonymous object <code>o2</code></li>
<li><code>o2</code> has a <code>baz</code> property which points to the string <code>&#39;blah&#39;</code></li>
</ul>
</li>
</ul>
<h3 id="type-introspection">Type Introspection</h3>
<p>There are 3 ways to instrospect into an object&#39;s &quot;type&quot;:</p>
<ul>
<li><code>typeof object === typeStr</code>. Limitation: <code>typeStr</code> is limited to strings
representing built-in types like <code>&#39;function&#39;</code>, <code>&#39;object&#39;</code>, <code>&#39;number&#39;</code>,
<code>&#39;string&#39;</code>, etc</li>
<li><code>object instanceof ConstructorFunction</code>. Limitation: you need a reference to
<code>ConstructorFunction</code> and it&#39;s not guaranteed that <code>ConstructorFunction</code>
was used to instantiate <code>object</code>. It could be higher up in the prototype
chain.</li>
<li><code>object.constructor === ConstructorFunction</code>. That&#39;s the most robust way to
check where an object comes from. This necessitates a reference to
<code>ConstructorFunction</code>.</li>
</ul>
<h3 id="achieving-inheritance-with-prototypes">Achieving Inheritance With Prototypes</h3>
<p>Achieving inheritance in JavaScript is as simple as using the prototype chain
lookup to our advantage so that &quot;inherited&quot; properties will be resolved
correctly, thus extending an object&#39;s capabilities.</p>
<pre class="brush: js">
    function B() {
        this.dataB = function() {...};
    };
    B.prototype.functionB = function() {...};

    function A() {
        this.functionA = function() {...};
    };
    A.prototype = new B();

    var a = new A();

    a.functionA(); // ok
    a.functionB(); // ok!
    a instanceof A; // ok
    a instanceof B; // ok!
</pre>

<p>Let&#39;s go through what happens when we call <code>a.functionB()</code>:</p>
<ul>
<li><code>a</code> refers to an object (returned from <code>new A()</code>)</li>
<li>that object doesn&#39;t have a <code>functionB</code> property</li>
<li>that object does have a <code>constructor</code> property, pointing to <code>A</code></li>
<li><code>A</code> has a <code>prototype</code> property, pointing to an object (returned from <code>new B()</code>)</li>
<li>that object does not have a <code>functionB</code> property</li>
<li>that object does have a <code>constructor</code> property, pointing to <code>B</code></li>
<li><code>B</code> has a <code>prototype</code> property, pointing to an object</li>
<li>that object has a <code>functionB</code> property. BINGO!</li>
</ul>
<p>Here&#39;s the complete reference chain:<br><code>a</code>-&gt;<code>(new A())</code>-&gt;<code>constructor</code>-&gt;<code>A</code>-&gt;<code>prototype</code><br>-&gt;<code>(new B())</code>-&gt;<code>constructor</code>-&gt;<code>B</code>-&gt;<code>prototype</code>-&gt;<code>functionB</code></p>
<h3 id="gotchas-and-tricks">Gotchas And Tricks</h3>
<p>Prototypes come with lots of bold warnings, the first of which is: be extra
careful when modifying/extending native objects&#39; prototypes!<br>There is only one <code>Array.prototype</code> for a whole page. Be aware that modifying
it is similar to modifying a global variable. Actually it&#39;s probably worse
because a lot of places are using <code>Array.prototype</code> in non-explicit ways.</p>
<p>In most browsers you can access native DOM element prototype and play with it:</p>
<pre class="brush: js">
    HTMLElement.prototype.addEventListener = function(type, fn, useProp) {
        console.log('trooooooll!'); // don't do that, seriously!
    };
</pre>

<p>Second gotcha: use <code>hasOwnProperty</code> to loop through object&#39;s properties.<br>Otherwise you&#39;ll loop through non-instance properties:</p>
<pre class="brush: js">
    Object.prototype.foo = 42;
    var obj = {a: 1, b: 2};

    for (var i in obj) { console.log(i); } 
    //-> logs 'a', 'b' *and 'foo'*

    for (var i in obj) { if (obj.hasOwnProperty(i)) { console.log(i); } }
    //-> logs 'a' and 'b'
</pre>


<p>Trick to ensure a function is always invoked as a constructor:</p>
<pre class="brush: js">
    function A() {
        if (!(this instanceof arguments.callee)) {
            return new A();
        }
        this.foo = 'bar';
    };
</pre>

<h2 id="timers">Timers</h2>
<p>JavaScript is <em>single-threaded</em>. That&#39;s really important to understand. Once
you grasp the fact that the browser has no choice but to queue handlers when
events are firing at the same time, understanding why timers cannot be reliable
is easy.</p>
<p>Browser APIs are well known: <code>window.setTimeout</code> and <code>window.setInterval</code> to
create timers, <code>window.clearTimeout</code> and <code>window.clearInterval</code> to clear them.</p>
<p>Nifty trick for all browsers and IE &gt; 9: timer functions can take arguments!
Like so:<br><code>window.setInterval(myfunction, 100, arg1, arg2)</code></p>
<p>Important note! There&#39;s a difference between:</p>
<pre class="brush: js">
    # Executes `fn` every 10ms by calling setInterval once
    window.setInterval(fn, 10);
</pre>

<p>and:</p>
<pre class="brush: js">
    # Executes `fn` every 10ms by calling setTimeout over and over
    window.setTimeout(function fn() {
        window.setTimeout(fn, 10)
    }, 10);
</pre>

<p>Second version is guaranteed to run every 10ms or more.<br>First version will try to execute every 10ms regardless of what happened before.</p>
<p>Cutting expensive computation into manageable chunks is an interesting
application of timers. Instead of doing a 100% of the work in a big chunk you
can choose to schedule manageable chunk via <code>setTimeout</code> thus enabling the
browser to do some work after each chunk finishes and before the next one
begins. Say a click event happens during a computation: the browser would get
a chance to execute the associated handler right after the current chunk is
done as opposed to waiting until the end of the whole computation.</p>
<p>Timers are also super useful to build asynchronous test suites and centralized
timers.<br>The idea is to have a single timer handling a queue (of tests to run or of
animations/functions to execute) so that the browser is not overwhelmed by
multiple timers. This centralized timer technique guarantees order of
execution. That&#39;s a perk we don&#39;t get when we use multiple native timers.</p>
<h2 id="cross-browser-strategies">Cross Browser Strategies</h2>
<p>Authoring cross-browser JavaScript is hard. Resig names 5 major concerns:</p>
<ul>
<li>Browser bugs</li>
<li>Browser bug fixes</li>
<li>Missing browser features</li>
<li>External code</li>
<li>Browser regressions</li>
</ul>
<p>Some strategies/advices to deal with browser bugs/differences:</p>
<ul>
<li>encapsulate your code into its own closure/unit, expose it as little as possible</li>
<li>degrade gracefully when features aren&#39;t available and/or bugs arise</li>
<li>&quot;Safe cross-browser fixes&quot;: no feature detection, no side effects. Example:
ignoring negative width/height value: <code>if ((key == &#39;width&#39; || key ==
&#39;height&#39;) &amp;&amp; parseFloat(value) &lt; 0) { value = undefined; }</code>. This makes the
buggy browser&#39;s API comply with the standard. It&#39;s a Good Thing Â®</li>
<li>&quot;Object detection&quot;: feature detection by inspecting a property/value of an
object. Example: bind event with W3C&#39;s <code>addEventListener</code> vs Microsoft&#39;s
<code>attachEvent</code>.</li>
<li>&quot;Feature simulation&quot;: create and execute a reduced test case to isolate the
buggy behavior. That creates a toggle to work around the bug in our code.
Very often that feature simulation is executed once at load time to minimize
performance impact.</li>
</ul>
<p>Interestingly enough Resig gives a list of &quot;untestable&quot; browser issues:</p>
<ul>
<li>Event handler bindings (no way to determine if a handler has been bound or not)</li>
<li>Event firing (no way to check if an event has been or will fire)</li>
<li>CSS property effects (does it affect appearance)</li>
<li>Browser crashes (if a feature makes the browser crash, feature simulation will too)</li>
<li>API performance (prohibitively expensive to test)</li>
<li>AJAX issues (tricky and expensive to test)</li>
</ul>
<h2 id="dom-attributes-and-properties">DOM Attributes and Properties</h2>
<p>There is an incredible amount of quirks involved in getting/setting DOM
attributes and properties. Ways to get properties/attributes of DOM nodes:</p>
<ul>
<li><code>elem.propertyName</code></li>
<li><code>elem.getAttribute(&#39;attributeName&#39;)</code></li>
<li><code>elem.getAttributeNode(&#39;attributeName&#39;).nodeValue</code> (recommanded way to get
the unaltered value)</li>
</ul>
<p>Note that attribute and property names aren&#39;t always the same. For instance
<code>class</code> is a valid attribute name but the associated property is <code>className</code>
The other ones are <code>for</code>, <code>readonly</code>, <code>maxlength</code>, <code>cellspacing</code>, <code>rowspan</code>,
<code>colspan</code>, <code>tabindex</code> which match respectively to the property names <code>htmlFor</code>,
<code>readOnly</code>, <code>maxLength</code>, <code>cellSpacing</code>, <code>rowSpan</code>, <code>colSpan</code>, <code>tabIndex</code>.)</p>
<p>Major quirks pointed out:</p>
<ul>
<li>Form input&#39;s <code>id</code>/<code>name</code> attributes are transferred on the form DOM node as
properties.  For instance if you have an input element with an <code>id</code>/<code>name</code>
attribute set to <code>foo</code>, <code>myForm.foo</code> will yield a reference this input.  Now
let&#39;s say you have an input with its <code>name</code>/<code>id</code> attribute set to <code>action</code>.
See the problem? Form element&#39;s original <code>action</code> property will be lost :/</li>
<li><code>href</code>, <code>src</code> or <code>action</code> perform URL normalization (you get a full canonical
URL when you might expect a relative URL)</li>
<li>input <code>type</code> attribute can&#39;t be changed after DOM node is inserted (IE only)</li>
<li>more problems around the <code>style</code> attribute: measuring <code>width</code> and <code>height</code>,
getting color, opacity or pixel measures. One interesting API:
<code>getComputedStyle</code> (or IE&#39;s <code>currentStyle</code>). It gives you the active CSS
property/value pairs for an element.</li>
</ul>
<h2 id="understanding-event-propagation">Understanding Event Propagation</h2>
<p>The order in which events are triggered throughout the DOM tree is not
consistent across browsers.</p>
<p>Netscape implements event propagation &quot;outside-in&quot;. An event propagates
from the root of the DOM tree all the way through its target (a button on which
you clicked for instance). This event propagation model is referred to as
<strong>capturing</strong>.</p>
<p>IE implements it in the exact opposite way: &quot;inside-out&quot;. An event
propagates from the target element up to the DOM tree&#39;s root. This event
propagation model is referred to as <strong>bubbling</strong></p>
<p>When the W3C had to choose, they didn&#39;t. Instead W3C&#39;s model lets you register
handlers for capturing or bubbling phase.<br>Concretely, compliant browsers will do the following when an event is triggered:</p>
<ol>
<li>start at DOM tree&#39;s root node. See if there are handlers set for <strong>capturing phase</strong> for our event type. If yes, call them.</li>
<li>go down one level in the tree, do the same (check and call potential handlers set for capturing)</li>
<li>go down one more level, do the same</li>
<li>...etc... (do the same and go down until we reach our event&#39;s target)</li>
<li>on the event&#39;s target (i.e.,the button we clicked) check and call potential handlers set for capturing</li>
<li>on the event&#39;s target, see if there are handlers set for <strong>bubbling phase</strong> for out event type. If yes, call them.</li>
<li>go up one level in the tree, do the same (check and call potential handlers set for bubbling)</li>
<li>go up one more level, do the same</li>
<li>...etc... (do the same and go up until we reach the DOM tree&#39;s root)</li>
<li>on DOM tree&#39;s root node, check and call potential handlers set for bubbling</li>
</ol>
<p>The standard API <code>elem.addEventListener(type, handler, useCapture)</code> has 3
params. First one is the type of event to listen to (&#39;click&#39;, &#39;focus&#39;, etc),
second is the handler we want to trigger when the type of event we&#39;re listening
to happens. The third parameter <code>useCapture</code> is the propagation phase we&#39;re interested in.</p>
<ul>
<li>if set to <code>false</code>, your handler will be called during the bubbling phase (step 6 through 10)</li>
<li>if set to <code>true</code>, your handler will be called during the capturing phase (step 1 through 5)</li>
<li><code>useCapture</code> defaults to <code>false</code></li>
</ul>
<p>Another important thing to consider: browsers have hooks to stop event
propagation at any point. Inside a handler, <code>e.stopPropagation()</code> and
<code>e.cancelBubble = true;</code> (in IE) will do just that.</p>
<p>That was a lengthy explanation but I think it describes what happens fairly
accurately. I hope that it will help you understand a few things. Namely:</p>
<ul>
<li><code>addEventListener(&#39;click&#39;, handler, false)</code> will have consistent behavior in
IE and modern browsers out-of-the-box (remember, IE&#39;s model only supports
bubbling phase). <strong>That&#39;s why jQuery won&#39;t let you set register handlers for
capturing phase</strong>. Letting you doing do wouldn&#39;t be cross-browser compatible.
jQuery supports bubbling in a cross browser fashion by emulating bubbling. In
browsers that don&#39;t support it, the library manually walks the DOM tree up to
call registered handlers. That&#39;s also how jQuery goes about supporting custom
events (<code>someJqueryElem.bind(&#39;my-custom-event&#39;, handler)</code>).</li>
<li><code>document.addEventListener(type, handler)</code> is a catch-all that will run
<strong>after</strong> every handler for this type in the path Root-Target has executed.</li>
<li><code>document.addEventListener(type, handler, true)</code> is a catch-all that will run
<strong>before</strong> every handler for this type of event in the path Root-Target
executes.</li>
<li>use <code>stopPropagation</code> and <code>cancelBubble = true</code> with <strong>extreme caution</strong>.
When you do that you&#39;re effectively preventing other handlers scheduled
to run after you from doing so.</li>
<li>when registering multiple handlers on the same element for the same event
type, order <strong>is not guaranteed</strong>.</li>
</ul>
<p>A good page to help you understand that if the explanation above didn&#39;t stick:
<a href="http://www.quirksmode.org/js/events_order.html">Quirksmode On Events</a></p>
<h2 id="jquery-s-event-system">jQuery&#39;s Event System</h2>
<p>At its core jQuery&#39;s event system doesn&#39;t rely much on the browser to work.
There are so many quirks that jQuery had to came up with a solution to
implement event binding, unbinding and triggering in a consistent manner.<br>Key ideas:</p>
<ul>
<li>the only handler actually registered by jQuery is a dispatcher. There is one
dispatcher per event type.</li>
<li>to keep track of individual handlers, each DOM element is given a <code>data</code>
property. Concretely it&#39;s a mapping of event type to an array of handler for
that type.</li>
<li>a dispatcher is responsible for looking at a DOM&#39;s data store and calling
handlers if it finds handlers registered for its type (remember, there is one
dispatcher per event type).</li>
<li>thus registering/unregistering a handler becomes equivalent to &quot;add/remove a
function to a DOM&#39;s data store&quot;</li>
</ul>
<p>This is really clever because it enables inventory of handlers at any point in
time and programmatic triggering of registered handler.</p>
<p>If you&#39;re interested in the nitty-gritty details head to <a href="https://github.com/jquery/jquery/blob/master/src/event.js">jQuery&#39;s
source</a></p>
<h2 id="concept-of-event-delegation">Concept Of Event Delegation</h2>
<p>jQuery&#39;s <code>.delegate(type, selector, handler)</code> (or <code>.on(type, selector,
handler)</code> in later versions) seems really magic if you don&#39;t understand
the concept of event delegation.</p>
<p>To put it in simple terms: <strong>event delegation is the process of registering a
handler high up in the DOM tree to handle events happening at lower levels.</strong><br>Event delegation is made possible by 2 things:</p>
<ul>
<li>event bubbling</li>
<li>ability to inspect event object&#39;s <code>target</code> property in handlers</li>
</ul>
<p>Concretely, instead of just doing some work, a delegated handler will <strong>check
the target first</strong> and <strong>then</strong> do some work:</p>
<pre class="brush: js">
    var doWork = function() { console.log('did some work'); }
    var button = document.findElementsByClassName('a-button')[0];

    // NON-DELEGATED version (the handler is bound directly)
    button.addEventListener('click', doWork, false); // use bubbling

    // DELEGATED version (we're checking the target first)
    document.addEventListener('click', function(e) {
        if (e.target.className === 'a-button') { // <== "Target check"
            doWork();
        }
    }, false); // use bubbling too
</pre>

<p>The delegated version above has several advantages:</p>
<ul>
<li>a button with class &#39;a-button&#39; can be inserted in the DOM <strong>after</strong> we
perform event binding. It&#39;s crucial if you&#39;re inserting content after an XHR
request for instance</li>
<li>multiple buttons with a class &#39;a-button&#39; could be on the page, things will
just work. This is awesome if you have behavior that you want to attach to a
big number of elements. Say you want to have JS behavior for all cells of a
HUGE table. Instead of looping through all the elements to bind a handler to
each and every one of those cells you can use delegation to bind a single
handler to a common container (the containing <code>&lt;table&gt;</code> element for instance)</li>
<li>hey we&#39;re not bound to just buttons anymore! Every element on page that
satisfies our target check gets to trigger <code>doWork</code> when clicked on.</li>
</ul>
<p>Of course jQuery is more sophisticated and lets you delegate your handler on a
container by specifying a <em>jQuery selector</em>. Under the hoods jQuery will check
if the event target matches this jQuery selector. If it does your handler will
be called.</p>
<h2 id="dom-manipulation">DOM Manipulation</h2>
<p>DOM manipulations are expensive. Libraries such as jQuery do a very good job of
thinking about performance which is why relying on an abstraction to manipulate
the DOM makes sense (manipulating the DOM yourself would most likely result in
your app being slow and leaking memory). For instance you&#39;re very unlikely to
use methods such as <code>createDocumentFragment</code> if you&#39;re authoring a one-off DOM
manipulation.</p>
<p>Steps to implement DOM insertion correctly:</p>
<ul>
<li><em>Parse the string into a HTML string</em>: no surprise there, pretty much What you
would expect: regular expression, yadda, yadda, yadda.</li>
<li><em>Create HTML nodes from the HTML string</em>: that step has to go around the fact
that certain elements have to be created within a specific element in order
to be inserted in the DOM successfully. For instance, <code>&lt;td&gt;</code> must be withing
a <code>&lt;tr&gt;</code>, which must be within a <code>&lt;tbody&gt;</code> which must be withing a <code>&lt;table&gt;</code>.
To go around those restrictions, the HTML string is wrapped before insertion,
elements are inserted in an empty div (using <code>innerHTML</code>), and used from there.</li>
<li><em>Insert those nodes into the document</em>: straightforward, except for the fact
that you have to deal with inline scripts potentially contained in the
collection of DOM nodes you&#39;re about to insert in the page. Workaround is to
delete <code>&lt;script&gt;</code> nodes from the inserted nodes and execute them
individually by inserting and removing them immediately after the <code>&lt;head&gt;</code>
tag.</li>
</ul>
<p><em>Removing</em> elements is tricky because you have to be careful to remove the
associated handlers not to create memory leaks.<br>Cloning elements is difficult in IE because IE copies not only the DOM node
but also event handlers (heh.)  </p>
<h2 id="conclusion-">Conclusion?</h2>
<p>If you found this article useful I highly recommend the full book,
<a href="http://www.manning.com/resig/">Secrets Of The JavaScript Ninja</a>. I personally
found the book super useful and illuminating in a lot of ways.</p>
<p>It&#39;s good to be able to read about &quot;real-world&quot; JavaScript, including about
browser quirks, language pitfalls and testing.</p>

</div>

<link href="/css/shCoreMidnight.css" rel="stylesheet" type="text/css" />
<script src="/js/shCore.js" type="text/javascript"></script>
<script src="/js/shAutoloader.js" type="text/javascript"></script>
<script type="text/javascript">
    SyntaxHighlighter.autoloader(
        'js jscript javascript  /js/shBrushJScript.js',
        'python                 /js/shBrushPython.js',
        'plain                  /js/shBrushPlain.js',
        'css                    /js/shBrushCss.js'
    );
    SyntaxHighlighter.all();
</script>
        </section>

        <footer>
          <h1>The End.</h1>
          <p>
            &mdash; &#10084; &mdash;
            <br />
            This is an open-source website.
            <a class="view-source" href="https://github.com/ArnaudBrousseau/arnaudbrousseau.com" target="_blank" title="Feeling brave enough?">
              Check out the source, Luke!
            </a>
          </p>
        </footer>

        <!-- Grab Google CDN's jQuery. fall back to local if necessary -->
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>
        <script>!window.jQuery && document.write('<script src="/js/jquery-1.4.3.min.js"><\/script>')</script>

        <script src="/js/script.js?v=1.1"></script>

        <!-- Google analytics - asynchronous mode -->
        <script>
          var _gaq = [['_setAccount', 'UA-19545721-1'], ['_trackPageview']];
          (function(d, t) {
            var g = d.createElement(t),
                s = d.getElementsByTagName(t)[0];
            g.async = true;
            g.src = '//www.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g, s);
          })(document, 'script');
        </script>
    </body>
</html>
